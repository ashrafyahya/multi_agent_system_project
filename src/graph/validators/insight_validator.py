"""Validator for insight node output.

Validates business insights against quality standards:
- SWOT completeness
- Minimum 3 insights
- Coherent trends

This validator follows the Validator Pattern, returning ValidationResult
objects instead of raising exceptions for validation failures.
"""

import logging
from typing import Any

from src.graph.validators.base_validator import BaseValidator, ValidationResult

logger = logging.getLogger(__name__)


class InsightValidator(BaseValidator):
    """Validates insight node output.
    
    This validator checks business insights generated by the insight agent
    to ensure they meet quality standards before proceeding to report
    generation. It validates SWOT completeness, insight count, and trend
    coherence.
    
    Validation checks:
    - SWOT analysis has at least some content in each category
    - Minimum 3 total insights (SWOT items + trends + opportunities + positioning)
    - Trends are coherent (non-empty, reasonable length)
    - Positioning is present and meaningful
    
    Example:
        ```python
        from src.graph.validators.insight_validator import InsightValidator
        
        validator = InsightValidator()
        result = validator.validate({
            "swot": {
                "strengths": ["Strong brand"],
                "weaknesses": ["High prices"],
                "opportunities": ["Emerging markets"],
                "threats": ["New competitors"]
            },
            "positioning": "Premium market leader",
            "trends": ["Digital transformation"],
            "opportunities": ["Expansion"]
        })
        
        if result.is_valid:
            print("Validation passed")
        else:
            for error in result.errors:
                print(f"Error: {error}")
        ```
    """
    
    MIN_INSIGHTS = 8  # Minimum 2 per SWOT category (8) + positioning (1) + trends (2) + opportunities (2) = 13 minimum
    MIN_SWOT_ITEMS_PER_CATEGORY = 2
    MIN_TRENDS = 2
    MIN_OPPORTUNITIES = 2
    MIN_POSITIONING_LENGTH = 50
    
    def validate(self, data: dict[str, Any]) -> ValidationResult:
        """Validate business insights.
        
        Performs comprehensive validation on insight node output to ensure
        insights are complete, meaningful, and coherent. Returns ValidationResult
        with errors and warnings, never raises exceptions.
        
        Validation checks performed:
        1. SWOT completeness - at least some items in each SWOT category
        2. Minimum 3 total insights across all categories
        3. Positioning is present and meaningful
        4. Trends are coherent (non-empty, reasonable content)
        5. Opportunities are meaningful
        
        Args:
            data: Insight output dictionary expected to contain:
                - "swot": Dictionary with SWOT components:
                  - "strengths": List[str]
                  - "weaknesses": List[str]
                  - "opportunities": List[str]
                  - "threats": List[str]
                - "positioning": str (required)
                - "trends": List[str]
                - "opportunities": List[str] (additional opportunities beyond SWOT)
        
        Returns:
            ValidationResult with:
            - is_valid: True if all validations pass
            - errors: List of error messages for validation failures
            - warnings: List of warning messages for non-critical issues
            
        Example:
            ```python
            validator = InsightValidator()
            result = validator.validate(insight_output)
            
            if not result.is_valid:
                logger.error(f"Validation failed: {result.get_summary()}")
                # Handle errors, possibly trigger retry
            ```
        """
        result = ValidationResult.success()
        
        # Check if data structure is valid
        if not isinstance(data, dict):
            result.add_error("Insight output must be a dictionary")
            return result
        
        # Validate SWOT structure
        swot_data = data.get("swot", {})
        if not isinstance(swot_data, dict):
            result.add_error("'swot' field must be a dictionary")
            return result
        
        # Validate SWOT completeness
        swot_errors = self._validate_swot_completeness(swot_data)
        for error in swot_errors:
            result.add_error(error)
        
        # Validate positioning
        positioning = data.get("positioning", "")
        if not positioning or not str(positioning).strip():
            result.add_error("'positioning' field is required and cannot be empty")
        else:
            positioning_length = len(str(positioning).strip())
            if positioning_length < self.MIN_POSITIONING_LENGTH:
                result.add_error(
                    f"Positioning is too short ({positioning_length} chars). "
                    f"Minimum {self.MIN_POSITIONING_LENGTH} characters required."
                )
            elif positioning_length < 100:
                result.add_warning(
                    f"Positioning seems short ({positioning_length} chars). "
                    "Consider providing more detail (recommended 100-500 characters)."
                )
        
        # Validate trends
        trends = data.get("trends", [])
        if not isinstance(trends, list):
            result.add_error("'trends' field must be a list")
        else:
            non_empty_trends = [t for t in trends if t and str(t).strip()]
            if len(non_empty_trends) < self.MIN_TRENDS:
                result.add_error(
                    f"Minimum {self.MIN_TRENDS} trends required, found {len(non_empty_trends)}"
                )
            trend_warnings = self._validate_trends_coherence(trends)
            for warning in trend_warnings:
                result.add_warning(warning)
        
        # Validate opportunities (additional to SWOT)
        opportunities = data.get("opportunities", [])
        if not isinstance(opportunities, list):
            result.add_error("'opportunities' field must be a list")
        else:
            non_empty_opportunities = [o for o in opportunities if o and str(o).strip()]
            if len(non_empty_opportunities) < self.MIN_OPPORTUNITIES:
                result.add_error(
                    f"Minimum {self.MIN_OPPORTUNITIES} opportunities required, "
                    f"found {len(non_empty_opportunities)}"
                )
        
        # Count total insights
        total_insights = self._count_insights(data)
        if total_insights < self.MIN_INSIGHTS:
            result.add_error(
                f"Minimum {self.MIN_INSIGHTS} insights required, "
                f"found {total_insights}. Insights include SWOT items, "
                "trends, opportunities, and positioning."
            )
        
        # Log validation result
        if result.is_valid:
            logger.info(
                f"Insight validation passed: {total_insights} insights validated"
            )
        else:
            logger.warning(
                f"Insight validation failed: {len(result.errors)} errors, "
                f"{len(result.warnings)} warnings"
            )
        
        return result
    
    def _validate_swot_completeness(self, swot_data: dict[str, Any]) -> list[str]:
        """Validate SWOT completeness.
        
        Checks that SWOT analysis has at least some content in each category.
        A complete SWOT should have items in strengths, weaknesses,
        opportunities, and threats.
        
        Args:
            swot_data: Dictionary containing SWOT components
        
        Returns:
            List of error messages (empty if validation passes)
        """
        errors: list[str] = []
        
        required_categories = ["strengths", "weaknesses", "opportunities", "threats"]
        
        for category in required_categories:
            category_data = swot_data.get(category, [])
            
            if not isinstance(category_data, list):
                errors.append(f"SWOT '{category}' must be a list")
                continue
            
            # Count non-empty items
            non_empty_items = [
                item for item in category_data
                if item and str(item).strip()
            ]
            
            if len(non_empty_items) < self.MIN_SWOT_ITEMS_PER_CATEGORY:
                errors.append(
                    f"SWOT '{category}' must have at least "
                    f"{self.MIN_SWOT_ITEMS_PER_CATEGORY} item(s), "
                    f"found {len(non_empty_items)}"
                )
        
        return errors
    
    def _validate_trends_coherence(self, trends: list[Any]) -> list[str]:
        """Validate trends coherence.
        
        Checks that trends are coherent - non-empty, reasonable length,
        and meaningful content.
        
        Args:
            trends: List of trend strings
        
        Returns:
            List of warning messages (empty if validation passes)
        """
        warnings: list[str] = []
        
        if not trends:
            warnings.append("No trends identified. Consider analyzing market trends.")
            return warnings
        
        # Check for very short trends
        short_trends = [
            idx for idx, trend in enumerate(trends)
            if trend and len(str(trend).strip()) < 5
        ]
        
        if short_trends:
            warnings.append(
                f"Some trends seem too short (indices: {short_trends}). "
                "Consider providing more detail."
            )
        
        # Check for duplicate trends
        trend_texts = [str(trend).lower().strip() for trend in trends if trend]
        if len(trend_texts) != len(set(trend_texts)):
            warnings.append("Duplicate trends detected. Consider consolidating.")
        
        return warnings
    
    def _count_insights(self, data: dict[str, Any]) -> int:
        """Count total number of insights.
        
        Counts insights across all categories:
        - SWOT items (strengths, weaknesses, opportunities, threats)
        - Trends
        - Opportunities (additional)
        - Positioning (counts as 1)
        
        Args:
            data: Insight data dictionary
        
        Returns:
            Total count of insights
        """
        count = 0
        
        # Count SWOT items
        swot_data = data.get("swot", {})
        if isinstance(swot_data, dict):
            for category in ["strengths", "weaknesses", "opportunities", "threats"]:
                category_items = swot_data.get(category, [])
                if isinstance(category_items, list):
                    # Count non-empty items
                    count += len([
                        item for item in category_items
                        if item and str(item).strip()
                    ])
        
        # Count trends
        trends = data.get("trends", [])
        if isinstance(trends, list):
            count += len([t for t in trends if t and str(t).strip()])
        
        # Count opportunities (additional)
        opportunities = data.get("opportunities", [])
        if isinstance(opportunities, list):
            count += len([o for o in opportunities if o and str(o).strip()])
        
        # Count positioning (1 if present and non-empty)
        positioning = data.get("positioning", "")
        if positioning and str(positioning).strip():
            count += 1
        
        return count
    
    @property
    def name(self) -> str:
        """Return validator name.
        
        Returns:
            String identifier for this validator
        """
        return "insight_validator"
